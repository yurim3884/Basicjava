package chapter06_;

public class Method {
	/*
	 * 메소드
	 * 똑같은 내용의 메소드를 기능별로 만들어놓고 원할 때 마다 호출하는 목적
	 * 
	 * 중요한 것
	 * 1.선언 방법 
	 * 2.호출 
	 * 
	 * 메소드 선언하는 것 
	 * 리턴(타입) 메소드 이름([매개변수 선언,.....]){
	 * 		코드
	 * }
	 * 
	 * -(타입): 메소드를 선언하고 호출한 다음 다시 돌려주는 타입의 데이터 타입 
	 * -{} : 실행을 해야하기 때문에 중가로 절대 필요
	 * 
	 * ex)
	 * 선언
	 *  
	 * void powerOn()
	 * double divide(int x, int y){.....}
	 * 
	 * void-리턴데이터가 없다
	 * double - 실행결과를 반납하는 타입
	 * 
	 * 호출
	 * powerOn();
	 * divide (10,20);
	 * 
	 * -호출시는 void 필요없음
	 * -선언시 {} 안의 코드 징행 -> 결과값을 double타입으로 반납
	 * - 리턴 값을 선언하지않고 호출 가능
	 * 
	 * 메소드이름
	 * - 숫자 시작 금지
	 * -$ _ 제외 특수문자 사용 불가
	 * -소문자 작성
	 * -혼합단어일시 단어 첫글자 대문자 ex)diceGame
	 * 
	 * 매개변수
	 * 
	 * 동작 
	 * (변환타입) 이름 ((변수타입)변수){}
	 * 
	 ******* 호출하지않으면 메소드 사용 불가******
	 * 
	 * 호출
	 * 이름 (매개값)
	 * 
	 * 메소드 호출 중요 
	 * 클래스 생성 중요
	 * 필드(변수)는 초기화 중요
	 * 
	 * 리턴 타입이 없으면  void
	 * 
	 * 메소드 오버로딩
	 * 클래스 내에 같은 이름의 메소드를 여러개 선언하는 것 
	 * 
	 * class 클래스{
	 * 	리턴타입 메소드 이름 (타입 변수 ,...)}
	 * -매개 변수의 타입 개수 순서가 달라야한다 
	 * 
	 * 
	 * 매개변수 존재 / 존재 X
	 * 리턴 값  존재 / 존재 X
	 * =>총 4가지의 경우의 수 
	 * 
	 * 매개변수 O 리턴 값 O  =>인터페이스 : 함수 function
	 * 매개변수 O 리턴 값 X  =>인터페이스 : 매개값을 소비 consumer
	 * 매개변수 X 리턴 값 O  =>인터페이스 : supplier 데이터를 궁금해한다(?)
	 * 매개변수 X 리턴 값 X  =>인터페이스 : runnable 실행하고 끝
	 * =
	 * predicate (판단)
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 */





}
